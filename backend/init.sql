-- FinGuard AI Database Initialization Script

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create enum types
CREATE TYPE risk_level AS ENUM ('low', 'medium', 'high', 'critical');
CREATE TYPE alert_status AS ENUM ('pending', 'reviewed', 'resolved', 'false_positive');
CREATE TYPE alert_severity AS ENUM ('info', 'warning', 'critical');
CREATE TYPE transaction_type AS ENUM ('purchase', 'withdrawal', 'transfer', 'deposit', 'refund', 'payment');

-- Create indexes concurrently to avoid locking
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

-- The tables will be created by SQLAlchemy, but here are additional optimizations:

-- Create performance indexes
CREATE INDEX IF NOT EXISTS idx_transactions_user_time 
ON transactions (user_id, transaction_time DESC);

CREATE INDEX IF NOT EXISTS idx_transactions_risk_time 
ON transactions (risk_score DESC, transaction_time DESC);

CREATE INDEX IF NOT EXISTS idx_transactions_merchant_time 
ON transactions (merchant_id, transaction_time DESC);

CREATE INDEX IF NOT EXISTS idx_transactions_device_time 
ON transactions (device_id, transaction_time DESC);

CREATE INDEX IF NOT EXISTS idx_alerts_status_time 
ON alerts (status, created_at DESC);

-- Create materialized view for daily fraud statistics
CREATE MATERIALIZED VIEW IF NOT EXISTS daily_fraud_stats AS
SELECT 
    DATE(transaction_time) as date,
    COUNT(*) as total_transactions,
    SUM(CASE WHEN is_fraudulent THEN 1 ELSE 0 END) as fraudulent_transactions,
    AVG(risk_score) as avg_risk_score,
    SUM(CASE WHEN is_fraudulent THEN amount ELSE 0 END) as fraud_amount,
    COUNT(DISTINCT user_id) as unique_users,
    COUNT(DISTINCT merchant_id) as unique_merchants
FROM transactions
GROUP BY DATE(transaction_time)
ORDER BY date DESC;

-- Create refresh function for materialized view
CREATE OR REPLACE FUNCTION refresh_daily_fraud_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY daily_fraud_stats;
END;
$$ LANGUAGE plpgsql;

-- Create function to get user risk profile
CREATE OR REPLACE FUNCTION get_user_risk_profile(user_uuid UUID)
RETURNS TABLE(
    total_transactions BIGINT,
    fraud_count BIGINT,
    avg_risk_score DECIMAL,
    last_transaction_time TIMESTAMP,
    risk_trend DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::BIGINT,
        SUM(CASE WHEN is_fraudulent THEN 1 ELSE 0 END)::BIGINT,
        AVG(risk_score),
        MAX(transaction_time),
        CASE 
            WHEN COUNT(*) >= 10 THEN 
                (AVG(CASE WHEN transaction_time > NOW() - INTERVAL '7 days' THEN risk_score ELSE NULL END) -
                 AVG(CASE WHEN transaction_time <= NOW() - INTERVAL '7 days' THEN risk_score ELSE NULL END))
            ELSE 0 
        END as risk_trend
    FROM transactions
    WHERE user_id = user_uuid;
END;
$$ LANGUAGE plpgsql;

-- Create function to detect potential fraud rings
CREATE OR REPLACE FUNCTION detect_fraud_rings()
RETURNS TABLE(
    device_id VARCHAR,
    ip_addresses JSONB,
    user_count BIGINT,
    fraud_count BIGINT,
    avg_risk_score DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.device_id,
        jsonb_agg(DISTINCT d.ip_addresses) as ip_addresses,
        COUNT(DISTINCT t.user_id)::BIGINT as user_count,
        SUM(CASE WHEN t.is_fraudulent THEN 1 ELSE 0 END)::BIGINT as fraud_count,
        AVG(t.risk_score) as avg_risk_score
    FROM transactions t
    JOIN devices d ON t.device_id = d.id
    GROUP BY t.device_id
    HAVING COUNT(DISTINCT t.user_id) > 3
       AND AVG(t.risk_score) > 70
    ORDER BY user_count DESC;
END;
$$ LANGUAGE plpgsql;

-- Grant permissions (adjust based on your security requirements)
GRANT SELECT ON ALL TABLES IN SCHEMA public TO finguard;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO finguard;

-- Create read-only user for analytics
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'analytics_reader') THEN
        CREATE USER analytics_reader WITH PASSWORD 'analytics_password';
    END IF;
END
$$;

GRANT CONNECT ON DATABASE finguard_db TO analytics_reader;
GRANT USAGE ON SCHEMA public TO analytics_reader;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO analytics_reader;
GRANT SELECT ON daily_fraud_stats TO analytics_reader;

-- Set up comment for documentation
COMMENT ON DATABASE finguard_db IS 'FinGuard AI Fraud Detection Database';
COMMENT ON TABLE transactions IS 'Financial transactions with fraud risk scores';
COMMENT ON TABLE alerts IS 'Fraud alerts generated by the system';
COMMENT ON TABLE explanations IS 'AI-generated explanations for risk scores';
COMMENT ON MATERIALIZED VIEW daily_fraud_stats IS 'Daily aggregated fraud statistics';

-- Log initialization
DO $$
BEGIN
    RAISE NOTICE 'FinGuard AI database initialized successfully';
END
$$;